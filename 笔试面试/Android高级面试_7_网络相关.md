# Android 高级面试-7：网络相关的三方库和网络协议等

## 1、网络框架

**问题：HttpUrlConnection, HttpClient, Volley 和 OkHttp 的区别？**

HttpUrlConnection 的基本使用方式如下：

```java
    URL url = new URL("http://www.baidu.com"); // 创建 URL
    HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // 获取 HttpURLConnection
    connection.setRequestMethod("GET"); // 设置请求参数
    connection.setConnectTimeout(5 * 1000);
    connection.connect();
    InputStream inputStream = connection.getInputStream(); // 打开输入流
    byte[] data = new byte[1024];
    StringBuilder sb = new StringBuilder();
    while (inputStream.read(data) != -1) { // 循环读取
        String s = new String(data, Charset.forName("utf-8"));
        sb.append(s);
    }
    message = sb.toString();
    inputStream.close(); // 关闭流
    connection.disconnect(); // 关闭连接
```

HttpURLConnect 和 HttpClient 的对比：

1. **功能方面**：HttpClient 库要`丰富很多，提供了很多工具`，封装了 http 的请求头，参数，内容体，响应，还有一些高级功能，代理、COOKIE、鉴权、压缩、连接池的处理。HttpClient 高级功能`代码写起来比较复杂`，对开发人员的要求会高一些，而 HttpURLConnection 对大部分工作进行了包装，屏蔽了不需要的细节，`适合开发人员直接调用`。另外，HttpURLConnection 在 2.3 版本增加了一些 HTTPS 方面的改进，4.0 版本增加一些响应的缓存。
2. **稳定性上**：HttpURLConnect 是一个通用的、适合大多数应用的轻量级组件。这个类起步比较晚，很容易在主要 API 上做稳步的改善。但是 HttpURLConnection 在 Android 2.2 及以下版本上`存在一些 bug`，尤其是在读取 InputStream 时调用 `close()` 方法，可能会导致连接池失效。Android `2.3 及以上版本`建议选用 HttpURLConnection，2.2 及以下版本建议选用 HttpClient。
3. **拓展方面**：HttpClient 的 API 数量过多，使得我们很难在不破坏兼容性的情况下对它进行升级和扩展，所以，目前 Android 团队在提升和优化 HttpClient 方面的`工作态度并不积极`。

OkHttp 和 Volley 的对比：

1. OkHttp：现代、快速、高效的 Http 客户端，支持 `HTTP/2 以及 SPDY`. Android 4.4 的源码中可以看到 HttpURLConnection 已经替换成 OkHttp 实现了。OkHttp `处理了很多网络疑难杂症`：会从很多常用的连接问题中自动恢复。OkHttp 还处理了代理服务器问题和 SSL 握手失败问题。
2. Volley：适合进行`数据量不大，但通信频繁的网络操作`；内部分装了异步线程；支持 Get，Post 网络请求和图片下载；可直接在主线程调用服务端并处理返回结果。缺点是：`1).对大文件下载 Volley 的表现非常糟糕；2).只支持 http 请求`。Volley 封装了访问网络的一些操作，底层在 Android 2.3 及以上版本，使用的是 HttpURLConnection，而在 Android 2.2 及以下版本，使用的是 HttpClient. 

**问题：OkHttp 源码？**

首先从整体的架构上面看，OkHttp 是基于`责任链设计模式`设计的，责任链的每一个链叫做一个拦截器。OkHttp 的请求是依次通过`重试、桥接、缓存、连接和访问服务器`五个责任链，分别用来：1).根据请求的`错误码`决定是否需要对连接进行重试；2).根据请求信息构建一个 key 用来从 DiskLruCache 中获取缓存，然后根据缓存的响应的信息判断该响应是否可用；3).缓存不可用的时候，使用连接拦截器建立服务器连接；4).最终在最后一个责任链从服务器中拿到请求结果。当从网络当中拿到了数据之后，会回到缓存连接器，然后在这里根据响应的信息和用户的配置决定是否缓存本次请求。除此默认的连接器，我们还可以自定义自己的拦截器。

OkHttp 的网络访问并没有直接使用 HttpUrlConnection 或者 HttpClient，而是直接使用 Socket 建立网络连接，对于流的读写，它使用了第三方的库 `okio`。在拿到一个请求的时候，OkHttp 首先会到连接池中寻找可以复用的连接。这里的连接池是使用双端队列维护的一个列表。当从连接池中获取到一个连接之后就使用它来进行网络访问。

**问题：Volley 实现原理？**

```java
    RequestQueue queue = Volley.newRequestQueue(this);
    // 针对不同的请求类型，Volley 提供了不同的 Request
    queue.add(new StringRequest(Request.Method.POST, "URL", new Response.Listener<String>() {
        @Override
        public void onResponse(String response) {
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
        }
    }));
```

底层在 Android 2.3 及以上版本，使用的是 HttpURLConnection，而在 Android 2.2 及以下版本，使用的是 HttpClient. 当创建一个 RequestQueue 的时候会同时创建 4 条线程用于从网络中请求数据，一条缓存线程用来从缓存中获取数据。因此不适用于数据量大、通讯频繁的网络操作，因为会占用网络请求的访问线程。

当调用 `add()` 方法的时候，会先判断是否可以使用缓存，如果可以则将其添加到缓存队列中进行处理。否则将其添加到网络请求队列中，用来从网络中获取数据。在缓存的分发器中，会开启一个无限的循环不断进行工作，它会先从阻塞队列中获取一个请求，然后判断请求是否可用，如果可用的话就将其返回了，否则将请求添加到网络请求队列中进行处理。

网络请求队列与之类似，它也是在 `run()` 方法中启动一个无限循环，然后使用阻塞队列获取请求，拿到请求之后来从网络中获取响应结果。

**问题：网络请求缓存处理，OkHttp 如何处理网络缓存的？**    
**问题：Http 请求头中都有哪些字段是与缓存相关的？**    
**问题：缓存到磁盘上的时候，缓存的键是根据哪些来决定的？**

OkHttp 的缓存最终是使用的 `DiskLruCache` 将请求的请求和响应信息存储到磁盘上。当进入到缓存拦截器的时候，首先会先从缓存当中获取请求的请求信息和响应信息。它会从响应信息的头部获取本次请求的缓存信息，比如过期时间之类的，然后判断该响应是否可用。如果可用，或者处于未连网状态等，则将其返回。否则，再从网络当中获取请求的结果。当拿到了请求的结果之后，还会再次回到缓存拦截器。缓存拦截器在拿到了响应之后，再根据响应和请求的信息决定是否将其持久化到磁盘上面。

http 请求头中用来控制决定缓存是否可用的信息：
1. `Expires`：缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点；
2. `Cache-Control`：相对时间，例如 Cache-Control:3600，代表着资源的有效期是 3600 秒，Cache-Control 与 Expires 可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control 优先级高。
3. `Last-Modify/If-Modify-Since`：Last-modify 是一个时间标识该资源的最后修改时间。
4. `ETag/If-None-Match`：一个校验码，ETag 可以保证每一个资源是唯一的，资源变化都会导致ETag 变化。ETag 值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的 If-None-Match 值来判断是否命中缓存。

客户端第一次请求的时候，服务器会返回上述各种 http 信息，第二次请求的时候会根据下面的流程进行处理：

![客户端第二次请求时的情况](res/940884-20180423141951735-912699213.png)

**问题：Retrofit 源码？**

Retrofit 的源码的两个核心地方：

1. 代理设计模式：JDK 动态代理，核心的地方就是调用 `Proxy.newProxyInstance()` 方法，来获取一个代理对象，但是这个方法要求传入的类的类型必须是接口类型，然后通过传入的 `InvocationHandler` 接口对我们定义的 Service 接口的方法进行解析，获取方法的注解等信息，并将其缓存起来。
2. 适配器设计模式和策略模式：设配器主要两个地方，也是 Retrofit 为人称道的地方，一个是对结果类型的适配，一个是对服务端返回类型的处理。前面的更像是适配器，后面的更像是策略接口。
     1. 以 RxJava 为例，当代理类的方法被调用的时候会返回一个 Observable. 然后，当我们对 Observable 进行订阅的时候将会调用 `subscribeActual()`，在该方法中根据之前解析的接口方法信息，将它们拼接成一个 OkHttp 的请求，然后使用 OkHttp 从网络中获取数据。
    2. 当拿到了数据之后就是如何将数据转换成我们期望的类型。这里 Retrofit 也将其解耦了出来。Retrofit 提供了 `Converter` 用作 OkHttp 的响应到我们期望类型的转换器。我们可以通过自己定义来实现自己的转换器，并选择自己满意的 Json 等转换框架。

## 2、网络基础

### 2.1 TCP 和 UDP

**问题：TCP 与 UDP 区别与应用？**    
**问题：TCP 中 3 次握手和 4 次挥手的过程**：

TCP，`传输控制协议`，`面向连接`，`可靠的`，基于`字节流`的传输层通信协议；    
UDP，`用户数据报协议`，`面向无连接`，`不可靠`，基于`数据报`的传输层协议。   

应用场景：

TCP 被用在对不能容忍数据丢失的场景中，比如用来发送 Http；    
UDP 用来可以容忍丢失的场景，比如网络视频流的传输。

具体区别：

1. TCP 协议是`有连接的`，有连接的意思是开始传输实际数据之前 TCP 的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而 UDP 是无连接的。
2. TCP 协议保证数据`按序发送`，`按序到达`，提供`超时重传`来保证可靠性，但是 UDP `不保证按序到达`，甚至`不保证到达`，只是努力交付，即便是按序发送的序列，也不保证按序送到。
3. TCP 协议`所需资源多`，TCP 首部需 20 个字节（不算可选项），UDP 首部字段只需8个字节。
4. TCP 有`流量控制和拥塞控制`，UDP 没有，网络拥堵不会影响发送端的发送速率。
5. TCP 是`一对一`的连接，而 UDP 则可以支持`一对一、多对多、一对多`的通信。
6. TCP 面向的是`字节流`的服务，UDP 面向的是`报文`的服务。

TCP 握手过程：

![3 次握手](res/tcp_3_hello.png)

1. 客户端通过 TCP 向服务器发送`SYN 报文段`。它不包含应用层信息，其中的`SYN 标志位为 1`，然后选择一个`初始序号 (client_isn)`，并将其放置在报文段的序号字段中。
2. 当 SYN 报文段到达服务器之后，服务器为该 TCP 连接分配 TCP 缓存和变量，并向该客户端发送`SYNACK 报文段`。它不包含应用层信息，其中个的`SYN 置为 1`，`确认号字段`被置为`client_isn+1`，最后服务器选择自己的`初始序号 (server_isn)` 放在序号字段中。
3. 客户端收到 SYNACK 报文段之后，为连接分配缓存和变量，然后向服务器发送另一个报文段，其中将 `server_isn+1` 放在`确认字段`中，并将`SYN 位置为 0`.

**问题：为什么要三次握手？**

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是`双方确认自己与对方的发送与接收是正常的`：

1. 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常。
2. 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常。
3. 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常。

![4 次挥手](res/tcp_4_bye.png)

1. 客户端向服务器发送关闭连接报文段，其中 `FIN` 置为 1。
2. 服务器接收到该报文段之后向发送方会送一个确认字段。
3. 服务器向客户端发送自己的终止报文段。
4. 客户端对服务器终止报文段进行确认。

**问题：为什么要四次挥手？**

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我要挂了”，B 回答 “我知道了”，但是 A 可能还会有要说的话，所以隔一段时间，B 再问 “真的要挂吗”，A 确认之后通话才算结束。

**问题：三次握手建立连接时，发送方再次发送确认的必要性？**

主要是为了防止已失效的连接请求报文段突然又传到了 B，因而产生错误。假定出现一种异常情况，即 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，一直延迟到连接释放以后的某个时间才到达 B，本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 又发出一次新的连接请求，于是就向 A 发出确认报文段，同意建立连接。假定不采用三次握手，那么只要 B 发出确认，新的连接就建立了，这样一直等待 A 发来数据，B 的许多资源就这样白白浪费了。

### 2.2 Http

#### 2.2.1 Http 协议

1. 全称`超文本传输协议`**`；
2. HTTP使用`TCP`作为它的支撑协议，TCP 默认使用 `80` 端口；
3. 它是`无状态的`，就是说它不会记录你之前是否访问过某个对象，它不保存任何关于客户的信息；
4. 它有两种连接方式，`非持续连接和持续连接`。它们的区别在于，非持续连接发送一个请求获取内容之后，对内容里的链接会再分别发送 TCP 请求获取；持续连接当获取到内容之后，`复用之前的 TCP` 获取相关的内容。后者节省了建立连接的时间，效率更高。

#### 2.2.2 HTTP 请求报文

```http
GET /somedir/page.jsp HTTP/1.1    部分 1：请求方法-统一资源标识符(URI)-协议/版本
Accept: text/plain; text/html     部分 2：请求头
Accept-Language: en-gb
Connection: keep-Alive
Host: localhost
User-Agent: Mozilla/4.0
Content-Length: 33
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate    
    
lastName=Franks&firstName=Michael 部分 3：实体
```

1. 请求方法共有`GET、POST、HEAD、PUT 和 DELETE`等，其中 `GET` 大约占 90%；HEAD 类似 GET，但不返回请求对象；PUT 表示上传对象到服务器；DELETE 表示删除服务器上的对象。
2. `URI` 是相应的 `URI` 的后缀，通常被解释为相对于服务器根目录的路径；
3. 请求头包含客户端和实体正文的相关信息，各个请求头之间使用 `“换行/回车”符(CRLF)` 隔开；
4. 请求头和实体之间有一个空行，该空行只有 CRLF 符，对 HTTP 格式非常重要。
5. `Host` 指明对象主机，它在 Web 代理高速缓存中有作用；
6. `Connection` 可取的值有 keep-Alive 和 close，分别对应持续连接和非持续连接；
7. `User-Agent` 指明向服务器发送请求的浏览器。

#### 2.2.3 HTTP 响应报文

```http
HTTP/1.1 200 OK                         部分 1：协议-状态码-描述
Server: Microft-IIS/4.0                 部分 2：响应头
Date: Mon, 5 Jan 2004 12:11：22 GMT
Content-Type: text/html
Last-Modified: Mon, 5 Jan 2004 11:11:11 GMT
Content-Length: 112                     

<html>.....</html>                      部分 3：响应实体段
```

1. 响应头和响应实体之间使用一个 CRLF 符分隔;
2. `Last-Modified` 缓存服务器中有作用；
3. 状态码的五种可能取值：
	1. `1xx`：指示信息--表示请求已接收，继续处理
	2. `2xx`：成功--表示请求已被成功接收、理解、接受
	3. `3xx`：重定向--要完成请求必须进行更进一步的操作
	4. `4xx`：客户端错误--请求有语法错误或请求无法实现
	5. `5xx`：服务器端错误--服务器未能实现合法的请求
3. 常见的状态码:
	1. `200` OK：请求成功；
	2. `301` Moved Permanelty: 请求对象被永久转移；
    3. `302` 重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，搜索搜索引擎认为新的网址是暂时的。而 301 重定向是永久的，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。
	4. `400` Bad Request: 请求不被服务器理解；
	5. `404` Not Found: 请求的文档不在服务器；
    6. `503` Service Unavailable：服务器出错的一种返回状态；
	7. `505` HTTP Version Not Supperted： 服务器不支持的HTTP协议。

#### 2.2.4 HTTP 1.0 与 2.0 的区别

1. HTTP/2 采用`二进制格式`而非文本格式；
2. HTTP/2 是完全`多路复用`的，而非有序并阻塞的——只需一个连接即可实现并行（多路复用允许单一的 HTTP/2 连接同时发起多重的请求-响应消息）；
3. 使用`报头压缩`，HTTP/2 降低了开销（不使用原来的头部的字符串，比如 UserAgent 等，而是从`字典`中获取，这需要在支持 HTTP/2 的浏览器和服务端之间运行）；
4. HTTP/2 让服务器可以将响应主动`推送`到客户端缓存中（说白了，就是 HTTP2.0 中，浏览器在请求 HTML 页面的时候，服务端会推送 css、js 等其他资源给浏览器，减少网络空闲浪费）。

#### 2.2.5 Http 长连接

在`HTTP/1.0`中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。

从`HTTP/1.1`起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码 `Connection:keep-alive`。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 `TCP 连接不会关闭`，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。`Keep-Alive 不会永久保持连接，它有一个保持时间`，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接`需要客户端和服务端都支持长连接`。

`HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。`

长连接可以省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测 TCP 连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client 端一般不会主动关闭它们之间的连接，Client 与 server 之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server 早晚有扛不住的时候，这时候 server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 server 端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个客户端连累后端服务。

### 2.3 Https

**问题：Https 请求慢的解决办法？DNS，携带数据，直接访问 IP**    
**问题：Http 与 Https 的区别以及如何实现安全性？**     
**问题：Https 原理？**    
**问题：Https 相关，如何验证证书的合法性，Https 中哪里用了对称加密，哪里用了非对称加密，对加密算法（如 RSA）等是否有了解？**

#### 2.3.1 Https 连接的过程

![Https 连接的过程](res/bg2014092004.png)

SSL 协议的握手过程共分成 5 各步骤，

1. 第一步，客户端给出`协议版本号`、一个客户端生成的`随机数`，以及客户端支持的`加密方法`；
2. 第二步，服务器确认双方使用的`加密方法`，并给出`数字证书`、以及一个服务器生成的`随机数`；
3. 第三步，客户端确认`数字证书`有效，然后生成一个新的`随机数`，并使用数字证书中的`公钥`加密这个随机数，发给服务器。
4. 第四步，服务器使用自己的`私钥`，获取客户端发来的随机数。
5. 第五步，客户端和服务器根据约定的`加密方法`，使用前面的`三个随机数`，生成`对话密钥`来加密接下来的整个对话过程。

握手阶段有三点需要注意。

1. 生成对话密钥一共需要`三个随机数`，然后使用这三个随机数来最终确定通话使用的算法；
2. 握手之后的对话使用对话密钥，服务器的公钥和私钥只用于加密和解密对话密钥，无其他作用；（握手之后开启的正式对话使用的是`对称加密`，即双方都能通过密钥进行解密；握手的过程中，协商最终使用哪种加密算法通话的时候是`非对称加密`，即私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。这样，服务端发送给客户端的消息不安全，但是客户端回复给服务端的消息是安全的。因为最后还要发送一个随机数用来确定最终的算法，所以这个过程安全就保证了最终的通话密钥是安全的。）
3. 服务器公钥放在服务器的数字证书之中。

然而直接使用非对称加密的过程本身也`不安全`，会有中间人`篡改公钥`的可能性，所以客户端与服务器不直接使用公钥，而是使用`数字证书签发机构颁发的证书`来保证非对称加密过程本身的安全。`第三方使用自己的私钥对公钥进行加密`，生成一个`证书`。然后`客户端从该证书中读取出服务器的公钥`。那么证书的合法性如何确认呢？我们可以使用浏览器或操作系统中维护的权威的第三方颁发机构的公钥，验证证书的编号是否正确。然后再使用第三方结构的公钥解密出我们服务器的公钥即可。

#### 2.3.2 HTTPS 与 HTTP 的一些区别

1. HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要`交费`。
2. HTTP 协议运行在 `TCP` 之上，所有传输的内容都是`明文`，HTTPS 运行在 `SSL/TLS` 之上，所有传输的内容都经过`加密`的。
3. HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 `80`，后者是 `443`。
4. HTTPS 可以有效的`防止运营商劫持`，解决了防劫持的一个大问题。

### 2.4 其他网络相关

**问题：描述一次网络请求的流程?**

![描述一次网络请求的流程](res/687472.webp)

浏览器输入域名之后，首先通过 DNS 查找该域名对应的 IP 地址。查找的过程会使用多级的缓存，包括浏览器、路由器和 DNS 的缓存。查找的 IP 地址之后，客户端向 web 服务器发送一个 HTTP 连接请求。服务器收到客户端的请求之后处理请求，并返回处理结果。客户端收到服务端返回的结果后将视图呈现给用户。

**问题：WebSocket 相关以及与 Socket 的区别**
**问题：谈谈你对 WebSocket 的理解**
**问题：WebSocket 与 socket 的区别**

WebSocket 是 HTML5 提供的一种在`单个 TCP 连接`上进行`全双工`通讯的协议，允许服务端主动向客户端推送数据。浏览器和服务器只需要完成`一次握手`，两者之间就直接可以创建持久性的连接，并进行`双向数据传输`。WebSocket 的请求和响应`报文的结构与 Http 相似`。相比于 ajax 这种通过不断`轮询`的方式来从服务端获取请求的方式，它通过类似于`推送`的方式通知客户端，可以节省更多的网络资源。

跟 Socket 的区别：Socket 其实`并非一个协议`，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。WebSocket 则是一个典型的`应用层协议`。总的来说：Socket 是`传输控制层协议`，WebSocket 是`应用层协议`。

## 参考：

1. [《Volley使用及其原理解析》](https://www.jianshu.com/p/fbbf2b1dfa46)
2. [《也许，这样理解HTTPS更容易》](http://blog.jobbole.com/110354/)
